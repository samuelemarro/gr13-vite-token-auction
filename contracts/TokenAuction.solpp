// SPDX-License-Identifier: MIT
/// @title Token Auction implementation for GR13 Hackathon
/// @author Samuele Marro

pragma soliditypp ^0.8.0;

import "./IndexedTree.solpp";

contract TokenAuction {
    using IndexedTree for IndexedTree.Tree;

    struct Auction {
        vitetoken tokenId;
        uint256 endTimestamp;
        uint256 amount;
        IndexedTree.Tree bids;
    }

    mapping(uint256 => Auction) private auctions;
    uint256 public numAuctions;

    // Comment these lines to disable the time hack
    //=====
    uint256 internal _currentTime = 0;

    function setTime(uint256 _time) external {
        _currentTime = _time;
    }

    function _getTime() internal view returns (uint256) {
        return _currentTime;
    }
    //=====

    // Uncomment these lines to disable the time hack
    //=====
    //function _getTime() internal view returns (uint256) {
    //    return block.timestamp;
    //}
    //=====
    
    function createAuction(vitetoken _tokenId, uint256 _amount, uint256 _endTimestamp) external payable returns(uint256) {
        require(_endTimestamp > _getTime(), "TokenAuction: end timestamp must be in the future");
        require(msg.token == _tokenId, "TokenAuction: token ID mismatch");
        require(msg.value == _amount, "TokenAuction: _amount must be equal to msg.value");

        uint256 auctionId = numAuctions++;
        auctions[auctionId].tokenId = _tokenId;
        auctions[auctionId].endTimestamp = _endTimestamp;
        auctions[auctionId].amount = _amount;

        return auctionId;
    }

    function auctionTokenId(uint256 _auctionId) external view returns(vitetoken) {
        require(_auctionId < numAuctions, "TokenAuction: auction ID out of range");
        return auctions[_auctionId].tokenId;
    }

    function auctionEndTimestamp(uint256 _auctionId) external view returns(uint256) {
        require(_auctionId < numAuctions, "TokenAuction: auction ID out of range");
        return auctions[_auctionId].endTimestamp;
    }

    function auctionAmount(uint256 _auctionId) external view returns(uint256) {
        require(_auctionId < numAuctions, "TokenAuction: auction ID out of range");
        return auctions[_auctionId].amount;
    }

    function _bidInfo(uint256 _auctionId, address _bidder) internal view returns (uint256, uint256) {
        return auctions[_auctionId].bids.get(_bidder);
    }

    function bidInfo(uint256 _auctionId, address _bidder) external view returns (uint256, uint256) {
        require(_auctionId < numAuctions, "TokenAuction: auction ID out of range");
        require(_bidExists(_auctionId, _bidder), "TokenAuction: bid does not exist");
        return _bidInfo(_auctionId, _bidder);
    }

    function _bidExists(uint256 _auctionId, address _bidder) internal view returns (bool) {
        return auctions[_auctionId].bids.exists(_bidder);
    }

    function bidExists(uint256 _auctionId, address _bidder) external view returns (bool) {
        return _bidExists(_auctionId, _bidder);
    }
    
    function bid(uint256 _auctionId, uint256 _amount, uint256 _price) external payable {
        require(_auctionId < numAuctions, "TokenAuction: auction does not exist");
        require(_price > 0, "TokenAuction: price must be positive");
        require(_amount > 0, "TokenAuction: amount must be positive");
        require(auctions[_auctionId].endTimestamp > _getTime(), "TokenAuction: auction has already ended");

        if (_bidExists(_auctionId, msg.sender)) {
            uint256 newBidTotal = _amount * _price;

            uint256 currentAmount;
            uint256 currentPrice;
            (currentAmount, currentPrice) = _bidInfo(_auctionId, msg.sender);
            uint256 currentBidTotal = currentAmount * currentPrice;

            if (newBidTotal > currentBidTotal) {
                // Bid is higher than current bid
                require(auctions[_auctionId].tokenId == msg.token, "TokenAuction: token ID mismatch");
                require(msg.value == newBidTotal - currentBidTotal, "TokenAuction: msg.value must be equal to new bid total - current bid total");
            }
            
            auctions[_auctionId].bids.update(msg.sender, _amount, _price);

            if (newBidTotal < currentBidTotal) {
                // Bid is higher than current bid
                // Executed later to avoid re-entrancy attacks
                payable(msg.sender).transfer(auctions[_auctionId].tokenId, currentBidTotal - newBidTotal);
            }
        } else {
            auctions[_auctionId].bids.insert(msg.sender, _amount, _price);
        }
    }

    function collect(uint256 _auctionId) external {
        require(_auctionId < numAuctions, "TokenAuction: auction does not exist");
        require(auctions[_auctionId].endTimestamp <= _getTime(), "TokenAuction: auction is still in progress");

        // TODO: Implement
    }
}