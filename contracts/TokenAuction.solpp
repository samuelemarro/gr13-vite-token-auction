// SPDX-License-Identifier: MIT
/// @title Token Auction implementation for GR13 Hackathon
/// @author Samuele Marro

pragma soliditypp ^0.8.0;

import "./IndexedTree.solpp";

contract TokenAuction {
    using IndexedTree for IndexedTree.Tree;

    struct Auction {
        vitetoken tokenId;
        uint256 endTimestamp;
        IndexedTree.Tree bids;
    }

    mapping(uint256 => Auction) private auctions;
    uint256 public numAuctions;

    function createAuction(vitetoken _tokenId, uint256 _amount, uint256 _endTimestamp) external payable {
        require(_endTimestamp > block.timestamp, "TokenAuction: end timestamp must be in the future");
        require(msg.token == _tokenId, "TokenAuction: token ID mismatch");
        require(msg.value == _amount, "TokenAuction: _amount must be equal to msg.value");

        uint256 auctionId = numAuctions++;
        auctions[auctionId].tokenId = _tokenId;
        auctions[auctionId].endTimestamp = _endTimestamp;
    }

    function _bidInfo(uint256 _auctionId, address _bidder) internal view returns (uint256, uint256) {
        return auctions[_auctionId].bids.get(_bidder);
    }

    function bidInfo(uint256 _auctionId, address _bidder) external view returns (uint256, uint256) {
        return _bidInfo(_auctionId, _bidder);
    }

    function _bidExists(uint256 _auctionId, address _bidder) internal view returns (bool) {
        return auctions[_auctionId].bids.exists(_bidder);
    }

    function bidExists(uint256 _auctionId, address _bidder) external view returns (bool) {
        return _bidExists(_auctionId, _bidder);
    }

    function bid(uint256 _auctionId, uint256 _amount, uint256 _price) external payable {
        require(_auctionId < numAuctions, "TokenAuction: auction does not exist");
        require(_price > 0, "TokenAuction: price must be positive");
        require(_amount > 0, "TokenAuction: amount must be positive");
        require(auctions[_auctionId].endTimestamp > block.timestamp, "TokenAuction: auction has already ended");

        require(auctions[_auctionId].tokenId == msg.token, "TokenAuction: token ID mismatch");

        if (_bidExists(_auctionId, msg.sender)) {
            uint256 newBidTotal = _amount * _price;

            uint256 currentAmount;
            uint256 currentPrice;
            (currentAmount, currentPrice) = _bidInfo(_auctionId, msg.sender);
            uint256 currentBidTotal = currentAmount * currentPrice;

            if (newBidTotal > currentBidTotal) {
                // Bid is higher than current bid
                require(msg.value == newBidTotal - currentBidTotal, "TokenAuction: msg.value must be equal to new bid total - current bid total");
            }

            auctions[_auctionId].bids.update(msg.sender, _amount, _price);

            if (newBidTotal < currentBidTotal) {
                // Bid is higher than current bid
                // Executed later to avoid re-entrancy attacks
                payable(msg.sender).transfer(auctions[_auctionId].tokenId, newBidTotal - currentBidTotal);
            }
        } else {
            auctions[_auctionId].bids.insert(msg.sender, _amount, _price);
        }
    }

    function collect(uint256 _auctionId) external {
        require(_auctionId < numAuctions, "TokenAuction: auction does not exist");
        require(auctions[_auctionId].endTimestamp <= block.timestamp, "TokenAuction: auction is still in progress");

        // TODO: Implement
    }
}